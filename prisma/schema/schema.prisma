generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextIndex", "fullTextSearch", "prismaSchemaFolder"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

generator dbml {
  provider = "prisma-dbml-generator"
}

model AppUser {
  id                    String            @id @db.Uuid
  email                 String            @unique
  fullName              String            @unique
  userName              String            @unique
  password              String
  avatarUrl             String?           @unique
  bio                   String?
  isActive              Boolean?          @default(false)
  privacyMode           PrivacyMode?      @default(PUBLIC)
  createdAt             DateTime          @default(dbgenerated("(now() AT TIME ZONE 'utc'::text)")) @db.Timestamptz(6)
  updatedAt             DateTime?         @db.Timestamptz(6)
  isDeleted             Boolean?          @default(false)
  blockedUsers          Block[]           @relation("blockBlockedIdToAppUser")
  blockingUsers         Block[]           @relation("blockBlockerIdToAppUser")
  comments              Comment[]
  CommentReaction       CommentReaction[]
  followedUsers         Follow[]          @relation("followFolloweeIdToAppUser")
  followers             Follow[]          @relation("followFollowerIdToAppUser")
  receivedNotifications Notification[]    @relation("notificationReceiverIdToAppUser")
  sentNotifications     Notification[]    @relation("notificationSenderIdToAppUser")
  postsByAvatarUrl      Post[]            @relation("postUserAvatarUrlToAppUser")
  postReactions         PostReaction[]
  sharesReceived        Share[]           @relation("shareReceiverIdToAppUser")
  sharesSent            Share[]           @relation("shareSenderIdToAppUser")
  tagsTagged            Tag[]             @relation("tagTaggedIdToAppUser")
  tagsTaggedBy          Tag[]             @relation("tagTaggerIdToAppUser")
}

model Post {
  id                 String         @id
  userId             String         @db.Uuid
  userName           String?
  userAvatarUrl      String?
  visibility         PostVisibility @default(PUBLIC)
  content            String
  createdAt          DateTime       @default(dbgenerated("(now() AT TIME ZONE 'utc'::text)")) @db.Timestamptz(6)
  updatedAt          DateTime?
  isDeleted          Boolean?       @default(false)
  attachments        Attachment[]
  comments           Comment[]
  notifications      Notification[]
  appUserByAvatarUrl AppUser?       @relation("postUserAvatarUrlToAppUser", fields: [userAvatarUrl], references: [avatarUrl], onDelete: NoAction, onUpdate: NoAction)
  postReactions      PostReaction[]
  shares             Share[]
  tags               Tag[]
}

model Attachment {
  id             Int               @id @default(autoincrement())
  postId         String
  commentId      Int
  storageUrl     String
  soundDuration  String?
  attachmentType AttachmentType?
  format         AttachmentFormat?
  isDeleted      Boolean?          @default(false)
  contentType    ContentType?
  createdAt      DateTime          @default(dbgenerated("(now() AT TIME ZONE 'utc'::text)")) @db.Timestamptz(6)
  comment        Comment           @relation(fields: [commentId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  post           Post              @relation(fields: [postId], references: [id], onDelete: Cascade, onUpdate: NoAction)
}

model Comment {
  id               Int               @id @default(autoincrement())
  userId           String?           @db.Uuid
  userAvatarUrl    String?
  userName         String?
  postId           String
  degree           Int?              @default(0)
  parentId         Int?
  content          String
  createdAt        DateTime          @default(dbgenerated("(now() AT TIME ZONE 'utc'::text)")) @db.Timestamptz(6)
  updatedAt        DateTime?
  isDeleted        Boolean?          @default(false)
  attachments      Attachment[]
  parentComment    Comment?          @relation("commentToComment", fields: [parentId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  replies          Comment[]         @relation("commentToComment")
  post             Post              @relation(fields: [postId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  user             AppUser?          @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  commentReactions CommentReaction[]
  notifications    Notification[]
  shares           Share[]
  tags             Tag[]
}

model Follow {
  id            Int            @id @default(autoincrement())
  followerId    String         @db.Uuid
  followeeId    String         @db.Uuid
  requestStatus FollowStatus   @default(PENDING)
  followedAt    DateTime?      @default(dbgenerated("(now() AT TIME ZONE 'utc'::text)")) @db.Timestamptz(6)
  acceptedAt    DateTime       @default(dbgenerated("(now() AT TIME ZONE 'utc'::text)")) @db.Timestamptz(6)
  followee      AppUser        @relation("followFolloweeIdToAppUser", fields: [followeeId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  follower      AppUser        @relation("followFollowerIdToAppUser", fields: [followerId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  Notification  Notification[]

  @@unique([followerId, followeeId])
}

model Block {
  id        Int       @id @default(autoincrement())
  blockerId String    @db.Uuid
  blockedId String    @db.Uuid
  createdAt DateTime? @default(dbgenerated("(now() AT TIME ZONE 'utc'::text)")) @db.Timestamptz(6)
  updatedAt DateTime  @default(dbgenerated("(now() AT TIME ZONE 'utc'::text)")) @db.Timestamptz(6)
  blocked   AppUser   @relation("blockBlockedIdToAppUser", fields: [blockedId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  blocker   AppUser   @relation("blockBlockerIdToAppUser", fields: [blockerId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([blockerId, blockedId])
}

model Tag {
  id                Int            @id @default(autoincrement())
  taggedId          String         @db.Uuid
  taggerId          String         @db.Uuid
  postId            String
  createdAt         DateTime       @default(dbgenerated("(now() AT TIME ZONE 'utc'::text)")) @db.Timestamptz(6)
  commentId         Int?
  postReactionId    Int?
  commentReactionId Int?
  notifications     Notification[]
  Comment           Comment?       @relation(fields: [commentId], references: [id])
  post              Post           @relation(fields: [postId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  tagged            AppUser        @relation("tagTaggedIdToAppUser", fields: [taggedId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  tagger            AppUser        @relation("tagTaggerIdToAppUser", fields: [taggerId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([taggerId, taggedId, postId])
}

model Notification {
  id                Int               @id @default(autoincrement())
  /// The user who send the notification. Could be tagger, commenter, follower, reactioner
  senderId          String            @db.Uuid
  senderUserName    String?
  senderAvatarUrl   String?
  /// The user who receive the notification
  receiverId        String            @db.Uuid
  /// Add id of relevants for future needs?
  followId          Int?
  postId            String?
  commentId         Int?
  postReactionId    Int?
  commentReactionId Int?
  tagId             Int?
  notificationType  NotificationType?
  createdAt         DateTime          @default(dbgenerated("(now() AT TIME ZONE 'utc'::text)")) @db.Timestamptz(6)
  isRead            Boolean?          @default(false)
  receiver          AppUser?          @relation("notificationReceiverIdToAppUser", fields: [receiverId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  sender            AppUser?          @relation("notificationSenderIdToAppUser", fields: [senderId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  Comment           Comment?          @relation(fields: [commentId], references: [id])
  Post              Post?             @relation(fields: [postId], references: [id])
  PostReaction      PostReaction?     @relation(fields: [postReactionId], references: [id])
  Follow            Follow?           @relation(fields: [followId], references: [id])
  Tag               Tag?              @relation(fields: [tagId], references: [id])
  CommentReaction   CommentReaction?  @relation(fields: [commentReactionId], references: [id])

  /// Only one notification per type is allowed
  @@unique([senderId, receiverId, notificationType])
}

model Share {
  id          Int          @id @default(autoincrement())
  senderId    String?      @db.Uuid
  receiverId  String?      @db.Uuid
  postId      String
  commentId   Int
  contentType ContentType?
  createdAt   DateTime     @default(dbgenerated("(now() AT TIME ZONE 'utc'::text)")) @db.Timestamptz(6)
  isDeleted   Boolean?     @default(false)
  comment     Comment      @relation(fields: [commentId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  post        Post         @relation(fields: [postId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  receiver    AppUser?     @relation("shareReceiverIdToAppUser", fields: [receiverId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  sender      AppUser?     @relation("shareSenderIdToAppUser", fields: [senderId], references: [id], onDelete: Cascade, onUpdate: NoAction)
}
